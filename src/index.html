<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>HBAR Exchange Rate Oracle Analysis - Interactive Chart</title>
    <script src="contrib/chart.umd.min.js"></script>
    <script src="contrib/chartjs-adapter-date-fns.bundle.min.js"></script>
    <script src="contrib/chartjs-plugin-zoom.min.js"></script>
    <script src="contrib/chartjs-plugin-annotation.min.js"></script>
    <script src="contrib/pako.min.js"></script>
    <link rel="stylesheet" href="index.css">
</head>

<body>

    <a class="github-logo" href="https://github.com/InternetOfPeers/hedera-hbar-exchange-rate-oracle-analysis"
        target="_blank" rel="noopener noreferrer" aria-label="View source on GitHub">
        <svg height="32" aria-hidden="true" viewBox="0 0 24 24" version="1.1" width="32" data-view-component="true">
            <path
                d="M12 1C5.923 1 1 5.923 1 12c0 4.867 3.149 8.979 7.521 10.436.55.096.756-.233.756-.522 0-.262-.013-1.128-.013-2.049-2.764.509-3.479-.674-3.699-1.292-.124-.317-.66-1.293-1.127-1.554-.385-.207-.936-.715-.014-.729.866-.014 1.485.797 1.691 1.128.99 1.663 2.571 1.196 3.204.907.096-.715.385-1.196.701-1.471-2.448-.275-5.005-1.224-5.005-5.432 0-1.196.426-2.186 1.128-2.956-.111-.275-.496-1.402.11-2.915 0 0 .921-.288 3.024 1.128a10.193 10.193 0 0 1 2.75-.371c.936 0 1.871.123 2.75.371 2.104-1.43 3.025-1.128 3.025-1.128.605 1.513.221 2.64.111 2.915.701.77 1.127 1.747 1.127 2.956 0 4.222-2.571 5.157-5.019 5.432.399.344.743 1.004.743 2.035 0 1.471-.014 2.654-.014 3.025 0 .289.206.632.756.522C19.851 20.979 23 16.854 23 12c0-6.077-4.922-11-11-11Z">
            </path>
        </svg>
    </a>

    <div class="container">
        <h1>HBAR Exchange Rate Oracle Analysis - Interactive Chart</h1>
        <p>Compare Hedera Oracle Exchange Rate vs CMC prices with percentage differences.<br />Hedera updates prices
            every hour. For CMC I used 5 mins, 15 mins, and 1 hour intervals in the past, but starting from mid August
            I'll run a script for having all the new data at 5 mins interval.
        </p>
        <div class="controls">
            <button onclick="resetZoom()">Reset Zoom</button>
            <button id="last1dBtn" onclick="showLastXDays(1)">Last 1 Day</button>
            <button id="last10dBtn" onclick="showLastXDays(10)" class="active">Last 10 Days</button>
            <button id="last30dBtn" onclick="showLastXDays(30)">Last 30 Days</button>
            <button id="allDataBtn" onclick="showAllData()">Show All Data</button>
            <button onclick="togglePercentageDiff()">Toggle % Difference</button>
            <button id="toggleTooltipBtn" onclick="toggleTooltip()">Hide Tooltip</button>
            <div class="threshold-control">
                <label for="acceptableRangeInput">Acceptable Range Threshold:</label>
                <input type="number" id="acceptableRangeInput" value="3" min="0" step="0.1">%
            </div>
        </div>

        <div class="chart-container">
            <div id="loading" class="loading">Loading chart data...</div>
            <canvas id="priceChart" style="display: none;"></canvas>
        </div>

        <div class="analytics-container">
            <div style="flex: 1;">
                <div class="threshold-panel">
                    <div class="threshold-analysis">
                        <div id="thresholdAnalysisGrid" class="threshold-grid"></div>
                    </div>
                </div>
            </div>

            <div style="flex: 1;">
                <div class="stats-panel">
                    <div class="stats-layout">
                        <div class="time-stat-row time-stats-grid">
                            <div class="stat-box time-stat">
                                <div>Current Time Window</div>
                                <div class="stat-value" id="timeWindowDisplay">-</div>
                            </div>
                            <div class="stat-box time-stat">
                                <div>Outside Threshold (<span id="currentThresholdDisplay">3%</span>)</div>
                                <div class="stat-value" id="timeOutsideThreshold">-</div>
                            </div>
                        </div>
                        <div class="other-stats-grid">
                            <div class="stat-box">
                                <div>Minimum Difference</div>
                                <div class="stat-value" id="minDiff">-</div>
                            </div>
                            <div class="stat-box">
                                <div>Maximum Difference</div>
                                <div class="stat-value" id="maxDiff">-</div>
                            </div>
                            <div class="stat-box">
                                <div>Median</div>
                                <div class="stat-value" id="medianDiff">-</div>
                            </div>
                            <div class="stat-box">
                                <div>Average</div>
                                <div class="stat-value" id="avgDiff">-</div>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </div>
        <div class="data-section">
            <h2>Data Management <small class="section-note">Advanced</small></h2>
            <div class="data-management-grid">
                <div class="data-instructions">
                    <p>
                        A compressed snapshot of the CSV is embedded in this page. Paste newer or custom data to
                        re-render the chart locally (no upload performed). The first line is ignored so you can keep
                        headers or comments there.
                    </p>
                    <div class="data-example">
                        <div class="example-title">Example Format</div>
                        <pre><code>Date,CMC,HEDERA
2025/07/04T07:00,0.1561745,0.15735433
2025/07/04T08:00,0.15483,0.15604
...
1756170900,0.2334577,0.23047166
1756171680,0.234483,0.23047166</code></pre>
                        <div class="data-hint">Supports ISO date strings (YYYY/MM/DDTHH:mm) or Unix timestamps (seconds
                            / ms).</div>
                    </div>
                </div>
                <div class="data-input-panel">
                    <div class="textarea-wrapper">
                        <label for="dataTextarea">Custom Data</label>
                        <textarea id="dataTextarea" placeholder="Paste your data here (Date,CMC,HEDERA)"></textarea>
                        <br /><br />
                        <div class="data-actions">
                            <button id="updateChartBtn" class="update-button saved" onclick="updateDataFromTextarea()"
                                title="Re-parse and refresh the chart">
                                <svg viewBox="0 0 24 24" aria-hidden="true">
                                    <path
                                        d="M12 5V2L8 6l4 4V7c3.309 0 6 2.691 6 6a6 6 0 0 1-6 6 5.99 5.99 0 0 1-5.65-4H4.062A8.003 8.003 0 0 0 12 22c4.411 0 8-3.589 8-8s-3.589-9-8-9z" />
                                </svg>
                                Update Chart
                            </button>
                        </div>
                        <div class="data-hint"><br />Changes not applied until you press Update Chart. Reload page to
                            restore embedded dataset.<br /> Parsing runs fully in your browser. Reload the page to
                            restore the original embedded dataset.</div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script>
        // Application state
        const state = { compressedCsvData: "H4sICFgyrmgAA3VuY29tcHJlc3NlZC1oYmFyLXByaWNlcy5jc3YAPZA7DsJADER7zhIhf8dOiUgkGhpuQMENuL9YEnu7kZ7ns7u9v5/l/rwvj33bX7cLhzNYjGihK7vDgUOFuqkWBzWPTD8UaHio+Irm4qqHMvzlyUWluUV4NZFOjiw+clyqKWa+0txHkCwVK1Dc5j5nLb95TH/0PhNda7/kzDfufaNJ+LzM0VX5Zr1Pkw2Vn5g8e5/aavX+cdjcpfcJk5x+lfHT+AHR9RRFjwEAAA==", chart: null, parsedData: [], showPercentageDiff: true, acceptableRangeLimit: 3, latestActiveButton: 'last10dBtn', showTooltip: true };

        let decompressedCsvData = null; function getDecompressedCsvData() { if (decompressedCsvData) return decompressedCsvData; try { const b = atob(state.compressedCsvData); const bytes = new Uint8Array(b.length); for (let i = 0; i < b.length; i++) bytes[i] = b.charCodeAt(i); decompressedCsvData = pako.inflate(bytes, { to: 'string' }); } catch (_) { decompressedCsvData = ''; } return decompressedCsvData; }

        // Update state to use decompressed data
        Object.defineProperty(state, 'csvData', {
            get: function () {
                return getDecompressedCsvData();
            }
        });

        // Removed duplicate state property reassignments

        // Utility functions
        const utils = {
            parseData(s) { const lines = s.trim().split(/\n+/); const out = []; for (let i = 1; i < lines.length; i++) { const line = lines[i]; if (!line) continue; const parts = line.split(/[\t,]/); if (parts.length < 3) continue; const ds = parts[0].trim(); const cmc = parseFloat(parts[1]); const hed = parseFloat(parts[2]); if (isNaN(cmc) || isNaN(hed)) continue; let date; if (/^\d+$/.test(ds)) { const ts = parseInt(ds, 10); date = new Date(ts < 10000000000 ? ts * 1000 : ts); } else { date = new Date(ds.replace('T', ' ')); } if (!isNaN(date.getTime())) out.push({ date, cmc, hedera: hed, percentDiff: ((hed - cmc) / cmc) * 100 }); } out.sort((a, b) => a.date - b.date); return out; },
            truncateToDecimals(v, d = 4) { const m = Math.pow(10, d); return Math.trunc(v * m) / m; },
            isOutlier(diff, threshold = state.acceptableRangeLimit) { return Math.abs(diff) > threshold; },
            isOutlierWithThreshold(diff, t) { return Math.abs(diff) > t; },
            createColorMap(d, fn) { return d.map(it => fn(it.percentDiff)); }
        };

        // Chart configuration
        const chartConfig = {
            createDatasets() { const hederaPts = [], cmcPts = [], diffPts = []; for (let i = 0; i < state.parsedData.length; i++) { const it = state.parsedData[i]; hederaPts.push({ x: it.date, y: it.hedera }); cmcPts.push({ x: it.date, y: it.cmc }); if (state.showPercentageDiff) diffPts.push({ x: it.date, y: it.percentDiff }); } const ds = [{ label: 'Hedera Price', data: hederaPts, borderColor: '#8A2BE2', backgroundColor: 'rgba(138,43,226,.2)', fill: false, yAxisID: 'y' }, { label: 'CMC Price', data: cmcPts, borderColor: '#00BFFF', backgroundColor: 'rgba(0,191,255,.2)', fill: false, yAxisID: 'y' }]; if (state.showPercentageDiff) { const outlierMap = utils.createColorMap(state.parsedData, utils.isOutlier); ds.push({ type: 'bar', label: 'Hedera vs CMC Difference', data: diffPts, borderColor: outlierMap.map(o => o ? 'rgb(255, 0, 0)' : 'rgb(255, 206, 86)'), backgroundColor: outlierMap.map(o => o ? 'rgba(255,0,0,1)' : 'rgba(255,206,86,.7)'), yAxisID: 'y1', barPercentage: 0.98, categoryPercentage: 0.98 }); } return ds; },

            createAnnotations() {
                if (!state.showPercentageDiff) return { display: false, annotations: {} };

                return {
                    display: true,
                    annotations: {
                        acceptableRange: {
                            type: 'box',
                            yMin: -state.acceptableRangeLimit,
                            yMax: state.acceptableRangeLimit,
                            backgroundColor: 'rgba(0, 255, 0, 0.05)',
                            borderColor: 'rgba(0, 255, 0, 0.3)',
                            borderWidth: 1,
                            yScaleID: 'y1'
                        },
                        outlierLineTop: {
                            type: 'line',
                            yMin: state.acceptableRangeLimit,
                            yMax: state.acceptableRangeLimit,
                            borderColor: 'rgba(255, 0, 0, 0.8)',
                            borderWidth: 2,
                            borderDash: [5, 5],
                            yScaleID: 'y1'
                        },
                        outlierLineBottom: {
                            type: 'line',
                            yMin: -state.acceptableRangeLimit,
                            yMax: -state.acceptableRangeLimit,
                            borderColor: 'rgba(255, 0, 0, 0.8)',
                            borderWidth: 2,
                            borderDash: [5, 5],
                            yScaleID: 'y1'
                        }
                    }
                };
            },

            getOptions() {
                return {
                    responsive: true,
                    maintainAspectRatio: false,
                    interaction: { mode: 'index', intersect: false },
                    elements: {
                        point: { pointStyle: false },
                        line: { borderJoinStyle: 'round' }
                    },
                    scales: {
                        x: {
                            type: 'time',
                            time: {
                                tooltipFormat: 'MMM dd, yyyy HH:mm',
                                displayFormats: {
                                    millisecond: 'HH:mm:ss.SSS',
                                    second: 'HH:mm:ss',
                                    minute: 'HH:mm',
                                    hour: 'MMM dd HH:mm',
                                    day: 'MMM dd',
                                    week: 'MMM dd',
                                    month: 'MMM yyyy',
                                    quarter: 'MMM yyyy',
                                    year: 'yyyy'
                                }
                            },
                            title: { display: true, text: 'Date UTC' },
                            ticks: {
                                source: 'data',
                                autoSkip: true,
                                maxRotation: 45,
                                callback: function (value, index, ticks) {
                                    const date = new Date(value);
                                    const scale = this.chart.scales.x;
                                    const range = scale.max - scale.min;

                                    // Determine format based on time range
                                    if (range <= 24 * 60 * 60 * 1000) { // Less than 1 day
                                        return date.toLocaleString('en-US', {
                                            hour: '2-digit',
                                            minute: '2-digit',
                                            hour12: false,
                                            timeZone: 'UTC'
                                        });
                                    } else if (range <= 7 * 24 * 60 * 60 * 1000) { // Less than 1 week
                                        return date.toLocaleString('en-US', {
                                            month: 'short',
                                            day: '2-digit',
                                            hour: '2-digit',
                                            minute: '2-digit',
                                            hour12: false,
                                            timeZone: 'UTC'
                                        });
                                    } else if (range <= 30 * 24 * 60 * 60 * 1000) { // Less than 1 month
                                        return date.toLocaleDateString('en-US', {
                                            month: 'short',
                                            day: '2-digit',
                                            timeZone: 'UTC'
                                        });
                                    } else {
                                        return date.toLocaleDateString('en-US', {
                                            year: 'numeric',
                                            month: 'short',
                                            timeZone: 'UTC'
                                        });
                                    }
                                }
                            },
                            grid: { offset: false },
                            offset: true
                        },
                        y: {
                            position: 'left',
                            title: { display: true, text: 'Price (USD)' },
                            ticks: {
                                callback: value => '$' + utils.truncateToDecimals(value).toFixed(4)
                            }
                        },
                        y1: {
                            display: state.showPercentageDiff,
                            position: 'right',
                            title: { display: true, text: 'Percentage Difference (%)' },
                            grid: { drawOnChartArea: false }
                        }
                    },
                    plugins: {
                        legend: {
                            onClick: chartEvents.onLegendClick,
                            labels: {
                                generateLabels: function (chart) {
                                    const original = Chart.defaults.plugins.legend.labels.generateLabels;
                                    const labels = original.call(this, chart);
                                    // Override color for the percentage difference dataset
                                    labels.forEach(label => {
                                        if (label.text === 'Hedera vs CMC Difference') {
                                            label.fillStyle = 'rgb(255, 206, 86)';
                                            label.strokeStyle = 'rgb(255, 206, 86)';
                                        }
                                    });
                                    return labels;
                                }
                            }
                        },
                        zoom: {
                            zoom: {
                                wheel: { enabled: true },
                                pinch: { enabled: true },
                                mode: 'x',
                                onZoomComplete: () => {
                                    statsManager.update();
                                    ui.setActiveButton(null);
                                }
                            }
                        },
                        tooltip: {
                            enabled: state.showTooltip,
                            position: 'hederaFixed',
                            callbacks: {
                                title: context => {
                                    if (context.length > 0) {
                                        const date = new Date(context[0].parsed.x);
                                        return date.toLocaleString('en-US', {
                                            month: 'short',
                                            day: '2-digit',
                                            year: 'numeric',
                                            hour: '2-digit',
                                            minute: '2-digit',
                                            hour12: false,
                                            timeZone: 'UTC',
                                            timeZoneName: 'short'
                                        });
                                    }
                                    return '';
                                },
                                label: context => {
                                    const { label } = context.dataset;
                                    let value = context.parsed.y;
                                    if (label.includes('Price')) {
                                        value = utils.truncateToDecimals(value).toFixed(4);
                                    } else if (label.includes('Difference')) {
                                        value = value.toFixed(2) + '%';
                                    }
                                    return `${value}: ${label}`;
                                }
                            }
                        },
                        annotation: this.createAnnotations()
                    }
                };
            }
        };

        // Chart event handlers
        const chartEvents = {
            onLegendClick(e, legendItem, legend) {
                const index = legendItem.datasetIndex;
                const chart = legend.chart;
                chart.setDatasetVisibility(index, !chart.isDatasetVisible(index));
                if (legendItem.text === 'Hedera vs CMC Difference') {
                    state.showPercentageDiff = !state.showPercentageDiff;
                    chart.options.scales.y1.display = state.showPercentageDiff;
                    if (chart.options.plugins.annotation) {
                        chart.options.plugins.annotation.display = state.showPercentageDiff;
                        Object.values(chart.options.plugins.annotation.annotations || {})
                            .forEach(annotation => annotation.display = state.showPercentageDiff);
                    }
                }
                chart.update();
            }
        };

        // Chart management
        const chartManager = {
            create() {
                state.acceptableRangeLimit = parseFloat(document.getElementById('acceptableRangeInput')?.value) || 3;
                const ctx = document.getElementById('priceChart').getContext('2d');

                // Register custom tooltip positioner
                Chart.Tooltip.positioners.fixedVerticalMouse = function (elements, eventPosition) {
                    if (elements.length > 0 && eventPosition) {
                        const chart = this.chart || this._chart;

                        // Follow mouse vertical position with bounds checking
                        const chartArea = chart.chartArea;
                        const minY = chartArea.top + 20; // 20px from top
                        const maxY = chartArea.bottom - 60; // 60px from bottom (tooltip height)

                        return {
                            x: eventPosition.x,
                            y: Math.max(minY, Math.min(eventPosition.y, maxY))
                        };
                    }
                    // Fallback to average positioning
                    return Chart.Tooltip.positioners.average.call(this, elements);
                };

                // Register custom tooltip positioner for Hedera value positioning
                Chart.Tooltip.positioners.hederaFixed = function (elements, eventPosition) {
                    if (elements.length > 0 && eventPosition) {
                        const chart = this.chart || this._chart;

                        // Find the Hedera price dataset element
                        let hederaElement = null;
                        for (let element of elements) {
                            const dataset = chart.data.datasets[element.datasetIndex];
                            if (dataset.label && dataset.label.includes('Hedera Price')) {
                                hederaElement = element;
                                break;
                            }
                        }

                        // If we found the Hedera element, use its Y position
                        if (hederaElement) {
                            const chartArea = chart.chartArea;
                            const tooltipHeight = 60; // Approximate tooltip height
                            const padding = 20;

                            // Use the Hedera price point's Y position
                            let targetY = hederaElement.element.y;

                            // Ensure tooltip stays within chart bounds
                            const minY = chartArea.top + padding;
                            const maxY = chartArea.bottom - tooltipHeight - padding;
                            targetY = Math.max(minY, Math.min(targetY, maxY));

                            return {
                                x: eventPosition.x,
                                y: targetY
                            };
                        }
                    }
                    // Fallback to average positioning
                    return Chart.Tooltip.positioners.average.call(this, elements);
                };

                // Register custom crosshair plugin
                const crosshairPlugin = {
                    id: 'crosshair',
                    beforeDraw: (chart) => {
                        if (chart.tooltip._active && chart.tooltip._active.length) {
                            const ctx = chart.ctx;
                            const activePoint = chart.tooltip._active[0];
                            const x = activePoint.element.x;
                            const topY = chart.scales.y.top;
                            const bottomY = chart.scales.y.bottom;
                            // Save the current state
                            ctx.save();
                            // Draw the vertical line
                            ctx.beginPath();
                            ctx.setLineDash([5, 5]);
                            ctx.moveTo(x, topY);
                            ctx.lineTo(x, bottomY);
                            ctx.lineWidth = 1;
                            ctx.strokeStyle = '#aaa';
                            ctx.stroke();
                            // Restore the state
                            ctx.restore();
                        }
                    }
                };

                // Custom drag-to-pan plugin
                const dragToPanPlugin = {
                    id: 'dragToPan',
                    beforeInit: function (chart) {
                        chart._dragToPan = {
                            isDragging: false,
                            lastX: null,
                            startX: null,
                            animationFrame: null,
                            pendingUpdate: false,
                            mouseDownHandler: null,
                            mouseMoveHandler: null,
                            mouseUpHandler: null,
                            mouseLeaveHandler: null
                        };

                        // Add direct event listeners to the canvas
                        const canvas = chart.canvas;
                        const dragData = chart._dragToPan;

                        dragData.mouseDownHandler = function (e) {
                            const rect = canvas.getBoundingClientRect();
                            const x = e.clientX - rect.left;
                            const y = e.clientY - rect.top;
                            const chartArea = chart.chartArea;

                            // Check if click is in chart area
                            if (x >= chartArea.left && x <= chartArea.right &&
                                y >= chartArea.top && y <= chartArea.bottom) {
                                dragData.isDragging = true;
                                dragData.lastX = x;
                                dragData.startX = x;
                                canvas.style.cursor = 'grabbing';
                                e.preventDefault();
                                e.stopPropagation();
                            }
                        };

                        dragData.mouseMoveHandler = function (e) {
                            const rect = canvas.getBoundingClientRect();
                            const x = e.clientX - rect.left;
                            const y = e.clientY - rect.top;
                            const chartArea = chart.chartArea;

                            const isInChartArea = x >= chartArea.left && x <= chartArea.right &&
                                y >= chartArea.top && y <= chartArea.bottom;

                            if (dragData.isDragging && dragData.lastX !== null) {
                                const deltaX = x - dragData.lastX;

                                // Only proceed if there's meaningful movement
                                if (Math.abs(deltaX) >= 2) {
                                    const scale = chart.scales.x;

                                    if (scale && scale.min !== undefined && scale.max !== undefined) {
                                        // Calculate the time range currently displayed
                                        const timeRange = scale.max - scale.min;
                                        const pixelRange = scale.right - scale.left;

                                        // Calculate time per pixel
                                        const timePerPixel = timeRange / pixelRange;

                                        // Calculate time delta (negative because dragging right should move timeline left)
                                        const timeDelta = -deltaX * timePerPixel;

                                        // Apply the pan
                                        const newMin = scale.min + timeDelta;
                                        const newMax = scale.max + timeDelta;

                                        // Update the scale limits directly
                                        chart.options.scales.x.min = newMin;
                                        chart.options.scales.x.max = newMax;

                                        // Update the chart with no animation for smooth dragging
                                        chart.update('none');

                                        // Mark that we need stats update
                                        dragData.pendingUpdate = true;
                                    }

                                    dragData.lastX = x;
                                }
                                e.preventDefault();
                                e.stopPropagation();
                            } else if (isInChartArea && !dragData.isDragging) {
                                canvas.style.cursor = 'grab';
                            } else if (!isInChartArea) {
                                canvas.style.cursor = 'default';
                            }
                        };

                        dragData.mouseUpHandler = function (e) {
                            if (dragData.isDragging) {
                                dragData.isDragging = false;
                                dragData.lastX = null;
                                dragData.startX = null;

                                const rect = canvas.getBoundingClientRect();
                                const x = e.clientX - rect.left;
                                const y = e.clientY - rect.top;
                                const chartArea = chart.chartArea;

                                if (x >= chartArea.left && x <= chartArea.right &&
                                    y >= chartArea.top && y <= chartArea.bottom) {
                                    canvas.style.cursor = 'grab';
                                } else {
                                    canvas.style.cursor = 'default';
                                }

                                // Update stats after dragging is complete
                                if (dragData.pendingUpdate) {
                                    setTimeout(() => {
                                        statsManager.update();
                                        ui.setActiveButton(null);
                                        dragData.pendingUpdate = false;
                                    }, 100);
                                }
                            }
                        };

                        dragData.mouseLeaveHandler = function (e) {
                            if (dragData.isDragging) {
                                dragData.isDragging = false;
                                dragData.lastX = null;
                                dragData.startX = null;
                                canvas.style.cursor = 'default';

                                // Update stats if we had pending changes
                                if (dragData.pendingUpdate) {
                                    setTimeout(() => {
                                        statsManager.update();
                                        ui.setActiveButton(null);
                                        dragData.pendingUpdate = false;
                                    }, 100);
                                }
                            } else {
                                canvas.style.cursor = 'default';
                            }
                        };

                        // Add event listeners
                        canvas.addEventListener('mousedown', dragData.mouseDownHandler);
                        canvas.addEventListener('mousemove', dragData.mouseMoveHandler);
                        canvas.addEventListener('mouseup', dragData.mouseUpHandler);
                        canvas.addEventListener('mouseleave', dragData.mouseLeaveHandler);
                    },
                    destroy: function (chart) {
                        // Clean up event listeners and animation frames
                        const canvas = chart.canvas;
                        const dragData = chart._dragToPan;

                        if (dragData) {
                            if (dragData.animationFrame) {
                                cancelAnimationFrame(dragData.animationFrame);
                            }

                            if (dragData.mouseDownHandler) {
                                canvas.removeEventListener('mousedown', dragData.mouseDownHandler);
                            }
                            if (dragData.mouseMoveHandler) {
                                canvas.removeEventListener('mousemove', dragData.mouseMoveHandler);
                            }
                            if (dragData.mouseUpHandler) {
                                canvas.removeEventListener('mouseup', dragData.mouseUpHandler);
                            }
                            if (dragData.mouseLeaveHandler) {
                                canvas.removeEventListener('mouseleave', dragData.mouseLeaveHandler);
                            }
                        }
                    }
                };
                state.chart = new Chart(ctx, {
                    type: 'line',
                    data: { datasets: chartConfig.createDatasets() },
                    options: chartConfig.getOptions(),
                    plugins: [crosshairPlugin, dragToPanPlugin]
                });
            },
            updateThreshold() {
                const { chart } = state;
                const currentXMin = chart.scales.x.min;
                const currentXMax = chart.scales.x.max;
                // Update colors and annotations
                if (state.showPercentageDiff) {
                    const diffDataset = chart.data.datasets.find(ds => ds.label === 'Hedera vs CMC Difference');
                    if (diffDataset) {
                        const outlierMap = utils.createColorMap(state.parsedData, utils.isOutlier);
                        diffDataset.borderColor = outlierMap.map(isOut => isOut ? 'rgb(255, 0, 0)' : 'rgb(255, 206, 86)');
                        diffDataset.backgroundColor = outlierMap.map(isOut => isOut ? 'rgba(255, 0, 0, 1)' : 'rgba(255, 206, 86, 0.9)');
                        diffDataset.barPercentage = 0.98;
                        diffDataset.categoryPercentage = 0.98;
                    }
                    const annotations = chart.options.plugins.annotation?.annotations;
                    if (annotations) {
                        ['acceptableRange', 'outlierLineTop', 'outlierLineBottom'].forEach(key => {
                            if (annotations[key]) {
                                annotations[key].yMin = key === 'outlierLineTop' ? state.acceptableRangeLimit : -state.acceptableRangeLimit;
                                annotations[key].yMax = key === 'outlierLineBottom' ? -state.acceptableRangeLimit : state.acceptableRangeLimit;
                            }
                        });
                    }
                }
                chart.options.scales.x.min = currentXMin;
                chart.options.scales.x.max = currentXMax;
                chart.update();
                statsManager.update();
            }
        };

        // Statistics management
        const thresholdsList = [1, 1.5, 2, 2.5, 3, 3.5, 4, 4.5, 5, 6, 7, 8, 9, 10];
        const statsManager = {
            update() {
                const dataToProcess = this.getVisibleData();
                if (dataToProcess.length === 0) {
                    this.clearStats();
                    return;
                }
                const percentDiffs = []; let sum = 0, min = Infinity, max = -Infinity; for (let i = 0; i < dataToProcess.length; i++) { const v = Math.abs(dataToProcess[i].percentDiff); percentDiffs.push(v); sum += v; if (v < min) min = v; if (v > max) max = v; } percentDiffs.sort((a, b) => a - b); const avg = sum / percentDiffs.length; const median = this.calculateMedian(percentDiffs); const timeStats = this.calculateTimeBasedStats(dataToProcess, state.acceptableRangeLimit); const stats = { min, max, avg, median, timeOutside: timeStats.minutesOutside, timePercentage: timeStats.percentage, totalTimeWindow: timeStats.totalMinutes };
                this.displayStats(stats);
                this.updateThresholdAnalysis(dataToProcess);
            },

            calculateTimeBasedStats(data, threshold) {
                if (data.length === 0) return { minutesOutside: 0, percentage: 0, totalMinutes: 0 };

                // Calculate total time window
                const firstDate = data[0].date;
                const lastDate = data[data.length - 1].date;
                const baseMinutes = (lastDate.getTime() - firstDate.getTime()) / (1000 * 60);
                const avgInterval = data.length > 1 ? baseMinutes / (data.length - 1) : 0;
                // Extend the window by one estimated interval to account for span of last point
                const totalMinutes = baseMinutes + avgInterval;

                // Calculate time outside threshold
                let minutesOutside = 0;
                for (let i = 0; i < data.length - 1; i++) {
                    const current = data[i];
                    const next = data[i + 1];

                    if (utils.isOutlierWithThreshold(current.percentDiff, threshold)) {
                        const timeDiff = (next.date.getTime() - current.date.getTime()) / (1000 * 60);
                        minutesOutside += timeDiff;
                    }
                }

                // Handle the last data point (assume it spans one average interval)
                if (data.length > 1 && utils.isOutlierWithThreshold(data[data.length - 1].percentDiff, threshold)) {
                    minutesOutside += avgInterval;
                }

                const percentage = totalMinutes > 0 ? (minutesOutside / totalMinutes) * 100 : 0;

                return {
                    minutesOutside: Math.max(0, minutesOutside),
                    percentage: Math.max(0, percentage),
                    totalMinutes: Math.max(0, totalMinutes)
                };
            },

            updateThresholdAnalysis(data) {
                const grid = document.getElementById('thresholdAnalysisGrid');
                // Clear and add header row (kept inside same grid for alignment)
                grid.innerHTML = '';
                const headers = ['Threshold', 'Time Outside', 'Percentage Outside', 'Percentage Inside'];
                headers.forEach(text => {
                    const h = document.createElement('div');
                    h.className = 'threshold-header';
                    h.textContent = text;
                    grid.appendChild(h);
                });
                thresholdsList.forEach(threshold => {
                    const stats = this.calculateTimeBasedStats(data, threshold);
                    const isCurrentThreshold = Math.abs(threshold - state.acceptableRangeLimit) < 0.01;
                    const isAllInside = stats.percentage <= 0.0000001; // Treat extremely small as 0
                    const buildClass = () => {
                        let cls = 'threshold-cell';
                        if (isCurrentThreshold) cls += ' current-threshold';
                        if (isAllInside) cls += ' all-inside';
                        return cls;
                    };

                    // Threshold cell
                    const thresholdCell = document.createElement('div');
                    thresholdCell.className = buildClass();
                    thresholdCell.textContent = `${threshold}%`;

                    // Time outside cell
                    const timeCell = document.createElement('div');
                    timeCell.className = buildClass();

                    if (stats.minutesOutside < 60) {
                        timeCell.textContent = `${Math.round(stats.minutesOutside)} mins`;
                    } else if (stats.minutesOutside < 1440) {
                        const hours = Math.floor(stats.minutesOutside / 60);
                        const minutes = Math.round(stats.minutesOutside % 60);
                        timeCell.textContent = `${hours}h ${minutes}m`;
                    } else {
                        const days = Math.floor(stats.minutesOutside / 1440);
                        const hours = Math.floor((stats.minutesOutside % 1440) / 60);
                        timeCell.textContent = `${days}d ${hours}h`;
                    }

                    // Percentage Outside cell
                    const percentCell = document.createElement('div');
                    percentCell.className = buildClass();
                    percentCell.textContent = `${stats.percentage.toFixed(2)}%`;

                    // Percentage Inside cell (clamped to >= 0 and <= 100)
                    const insidePct = Math.min(100, Math.max(0, 100 - stats.percentage));
                    const percentInsideCell = document.createElement('div');
                    percentInsideCell.className = buildClass();
                    percentInsideCell.textContent = `${insidePct.toFixed(2)}%`;

                    grid.appendChild(thresholdCell);
                    grid.appendChild(timeCell);
                    grid.appendChild(percentCell);
                    grid.appendChild(percentInsideCell);
                });
            },
            getVisibleData() {
                if (!state.chart?.scales?.x) return state.parsedData;
                const { min, max } = state.chart.scales.x;
                if (!min || !max) return state.parsedData;
                return state.parsedData.filter(item => {
                    const time = item.date.getTime();
                    return time >= min && time <= max;
                });
            },
            calculateMedian(sortedArray) {
                const mid = Math.floor(sortedArray.length / 2);
                return sortedArray.length % 2 === 0
                    ? (sortedArray[mid - 1] + sortedArray[mid]) / 2
                    : sortedArray[mid];
            },
            displayStats(stats) {
                const elements = ['minDiff', 'medianDiff', 'avgDiff', 'maxDiff'];
                const values = [stats.min, stats.median, stats.avg, stats.max];
                elements.forEach((id, index) => {
                    const element = document.getElementById(id);
                    element.textContent = values[index].toFixed(4) + '%';
                    const shouldWarn = values[index] > state.acceptableRangeLimit;
                    element.classList.toggle('outliers-warning', shouldWarn);
                });

                // Display current visible time window (extended by one estimated interval like stats calculation)
                const windowEl = document.getElementById('timeWindowDisplay');
                if (windowEl) {
                    const data = this.getVisibleData();
                    if (data.length > 1) {
                        const first = data[0].date;
                        const last = data[data.length - 1].date;
                        const baseMinutes = (last.getTime() - first.getTime()) / (1000 * 60);
                        const avgInterval = baseMinutes / (data.length - 1);
                        const totalMinutes = baseMinutes + avgInterval; // extended window
                        if (totalMinutes < 60) {
                            windowEl.textContent = `${Math.round(totalMinutes)} mins`;
                        } else if (totalMinutes < 1440) {
                            const hours = Math.floor(totalMinutes / 60);
                            const minutes = Math.round(totalMinutes % 60);
                            windowEl.textContent = `${hours}h ${minutes}m`;
                        } else {
                            const days = Math.floor(totalMinutes / 1440);
                            const hours = Math.floor((totalMinutes % 1440) / 60);
                            windowEl.textContent = `${days}d ${hours}h`;
                        }
                    } else {
                        windowEl.textContent = '-';
                    }
                }

                // Update current threshold display
                const thresholdDisplay = document.getElementById('currentThresholdDisplay');
                if (thresholdDisplay) {
                    thresholdDisplay.textContent = `${state.acceptableRangeLimit}%`;
                }

                // Update time outside threshold
                const timeElement = document.getElementById('timeOutsideThreshold');
                if (stats.timeOutside < 60) {
                    timeElement.textContent = `${Math.round(stats.timeOutside)} mins (${stats.timePercentage.toFixed(2)}%)`;
                } else if (stats.timeOutside < 1440) {
                    const hours = Math.floor(stats.timeOutside / 60);
                    const minutes = Math.round(stats.timeOutside % 60);
                    timeElement.textContent = `${hours}h ${minutes}m (${stats.timePercentage.toFixed(2)}%)`;
                } else {
                    const days = Math.floor(stats.timeOutside / 1440);
                    const hours = Math.floor((stats.timeOutside % 1440) / 60);
                    timeElement.textContent = `${days}d ${hours}h (${stats.timePercentage.toFixed(2)}%)`;
                }

                // Turn red if any time is spent outside the threshold (> 0 minutes)
                //const shouldWarnTime = stats.timeOutside > 0;
                //timeElement.classList.toggle('outliers-warning', shouldWarnTime);

                // Turn red if time percentage spent outside the threshold (> 5%)
                const shouldWarnTime = stats.timePercentage > 5;
                timeElement.classList.toggle('outliers-warning', shouldWarnTime);

            },
            clearStats() {
                ['minDiff', 'medianDiff', 'avgDiff', 'maxDiff', 'timeOutsideThreshold'].forEach(id => {
                    const element = document.getElementById(id);
                    element.textContent = '-';
                    element.classList.remove('outliers-warning');
                });

                const windowEl = document.getElementById('timeWindowDisplay');
                if (windowEl) windowEl.textContent = '-';

                // Clear threshold analysis grid
                const grid = document.getElementById('thresholdAnalysisGrid');
                if (grid) grid.innerHTML = '';
            }
        };

        // UI management
        const ui = {
            setActiveButton(activeId) {
                ['resetBtn', 'last1dBtn', 'last10dBtn', 'last30dBtn', 'allDataBtn'].forEach(id => {
                    document.getElementById(id)?.classList.remove('active');
                });
                if (activeId) {
                    document.getElementById(activeId)?.classList.add('active');
                    // Track the latest active button (only for time range buttons)
                    if (['last1dBtn', 'last10dBtn', 'last30dBtn', 'allDataBtn'].includes(activeId)) {
                        state.latestActiveButton = activeId;
                    }
                }
            },
            filterByTimeRange(hours, buttonId) {
                // Use the last timestamp from the data as "now"
                const lastDataPoint = state.parsedData[state.parsedData.length - 1];
                const now = lastDataPoint ? lastDataPoint.date : new Date();
                const startTime = new Date(now.getTime() - (hours * 60 * 60 * 1000));
                state.chart.options.scales.x.min = startTime;
                state.chart.options.scales.x.max = now;
                state.chart.update();
                statsManager.update();
                this.setActiveButton(buttonId);
            }
        };

        // Public API functions
        function resetZoom() {
            state.chart.resetZoom();
            // Restore the previously active time range button
            ui.setActiveButton(state.latestActiveButton);
        }

        function showLastXDays(days) {
            ui.filterByTimeRange(days * 24, `last${days}dBtn`);
        }

        function showAllData() {
            state.chart.options.scales.x.min = undefined;
            state.chart.options.scales.x.max = undefined;
            state.chart.update();
            statsManager.update();
            ui.setActiveButton('allDataBtn');
        }

        function togglePercentageDiff() {
            state.showPercentageDiff = !state.showPercentageDiff;
            state.chart.destroy();
            chartManager.create();
            statsManager.update();
        }

        function updateDataFromTextarea() {
            const newData = document.getElementById('dataTextarea').value;
            if (newData.trim()) {
                state.parsedData = utils.parseData(newData);
                state.chart.destroy();
                chartManager.create();
                statsManager.update();
                // mark button as saved
                const btn = document.getElementById('updateChartBtn');
                if (btn) {
                    btn.classList.remove('unsaved');
                    btn.classList.add('saved');
                }
            } else {
                alert('Please paste some data first.');
            }
        }

        function toggleTooltip() {
            state.showTooltip = !state.showTooltip;
            const button = document.getElementById('toggleTooltipBtn');

            // Update button text
            button.textContent = state.showTooltip ? 'Hide Tooltip' : 'Show Tooltip';

            // Update chart tooltip configuration
            state.chart.options.plugins.tooltip.enabled = state.showTooltip;
            state.chart.update();
        }

        // Optimized initialization
        async function init() {
            console.time('Total initialization');

            // Parse data asynchronously to avoid blocking
            await new Promise(resolve => {
                setTimeout(() => {
                    state.parsedData = utils.parseData(state.csvData);
                    resolve();
                }, 0);
            });

            // Hide loading indicator and show chart
            document.getElementById('loading').style.display = 'none';
            document.getElementById('priceChart').style.display = 'block';

            document.getElementById('dataTextarea').value = state.csvData;

            // Create chart
            chartManager.create();

            // Show initial data
            showLastXDays(10);

            // Update stats
            statsManager.update();

            // Setup threshold input listener
            const input = document.getElementById('acceptableRangeInput');
            if (input && !input._listenerAdded) {
                input.addEventListener('change', function () {
                    state.acceptableRangeLimit = parseFloat(this.value) || 3;
                    if (state.chart) chartManager.updateThreshold();
                });
                input._listenerAdded = true;
            }

            // Track textarea changes for unsaved indicator
            const dataTextarea = document.getElementById('dataTextarea');
            const updateBtn = document.getElementById('updateChartBtn');
            if (dataTextarea && updateBtn && !dataTextarea._listenerAdded) {
                const markUnsaved = () => {
                    updateBtn.classList.remove('saved');
                    updateBtn.classList.add('unsaved');
                };
                ['input', 'change', 'paste'].forEach(evt => dataTextarea.addEventListener(evt, markUnsaved));
                dataTextarea._listenerAdded = true;
            }

            console.timeEnd('Total initialization');
        }

        // Use DOMContentLoaded for faster startup
        document.addEventListener('DOMContentLoaded', init);
    </script>
</body>

</html>